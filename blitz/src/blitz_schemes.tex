\section{Методы построения схем\label{s:methods}}
	\subsection{Структура схемы\label{ss:split}}
	Существуют методы, которые строят упрощенные, в некотором смысле, \svp{}. В корневых узлах такой схемы стоят не первые степени переменных, а некоторые нетривиальные мономы, которые, в свою очередь, могут быть вычислены различными способами. Соответственно, для них можно построить отдельную схему, называемую схемой \textit{совместного вычисления мономов} (\ssvm).
	
	\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{../pic/split}
	\caption{Схема для $x^2y^3+xy^4$ как композиция двух схем. Пунктиром выделен переход.}
	\label{fig:split}
	\end{figure}

	Можно рассматривать это как разбиение схемы на две части (рис. \ref{fig:split}). Формально они отличаются лишь тем, что нижняя не содержит операций сложения. Методы построения \ssvm{} мы рассмотрим в разделе \ref{ss:addchain}.	

	В данной работе мы рассматриваем методы, сохраняющие количество сложений и все операции умножения на коэффициенты. Более того, во всех методах, кроме метода Горнера, домножение на коэффициенты и суммирование производятся в конце. Следовательно, в этих случаях мы можем отбросить эти операции и рассматривать задачу вычисления набора одночленов, то есть задачу построения \ssvm{}.
	 
	 Мы будем обозначать носитель рассматриваемого полинома как $M$, а множество его переменных как $V$.

	\subsection{Сложность построения оптимальной схемы\label{ss:complexity}}
		Пусть задан критерий качества $f: s\rightarrow h, s\in S, h\in \mathbb{R}$, где $S$ -- множество возможных схем. Необходимо для заданного полинома $p(\bar{x})=\sum_i{c_i\bar{x}^{\bar{\alpha}_i}}$ построить отвечающую ему схему с наибольшим возможным $h$.
		
		В разд. \ref{ss:addchain} мы рассмотрим задачу о построении кратчайшей аддитивной последовательности, которая NP-полна и эквивалентна задаче построения оптимальный \svp{} для вычисления значений полинома в числах фиксированной длины с плавающей точкой. Нам неизвестно формального доказательства NP-полноты для построения оптимальной \svp{} для задачи редукции, однако интуитивно можно предполагать, что усложнение критерия качества не приведет к уменьшению сложности построения схемы.
				
	\subsection{Тривиальная схема\label{ss:simple}}
	Существует схема, которая не требует построения -- она зафиксирована в форме записи полинома. Согласно этой схемы, мы должны сначала вычислить все мономы, встречающиеся в полиноме, а затем просуммировать результаты. Мы будем называть эту схему тривиальной.
	
	\subsection{Обобщенный метод Горнера\label{ss:gorner}}
	Обобщенный (на случай полиномов многих переменных) метод Горнера (ОМГ) прост в реализации и позволяет получать достаточно хорошие схемы. Алгоритм построения \ref{alg:horner} является рекурсивным. Фактически, он представляет исходный полином $t$ в виде $t=pd+q$, причем ни один член $q$ не делится на $d$. Затем операция повторяется для $p$ и $q$, до тех пор, пока на месте $t$ не окажется одночленом.
		
		Легко видеть, что число рекурсивных вызовов не превышает число членов в исходном полиноме. Сложность каждого вызова составляет $O(n)$ операций вычисления наибольшего общего делителя двух одночленов $GCD$. Всего не более $O(n^2)$ операций $GCD$. Сложность одной такой операции можно считать постоянной, если ограничить величину коэффициентов некоторой константой и зафиксировать число переменных.
				
\begin{algorithm}
\SetAlgoNoLine
\DontPrintSemicolon
\KwIn{список $T$ членов полинома в порядке убывания, контейнер схемы $S$}
$P\leftarrow \{\}$\;
$d\leftarrow T[0]$\;
\If{Length(T)$=1$}{
\Return{\textit{AddNode}$(S,T[0])$}
}
\ForEach{$t\in T$} {
	$g\leftarrow $\textit{GCD}$(t,d)$\;
	\If{TotalDegree$(g)>0$}{
		$P\leftarrow P\cup\{t\}$\;
		$d\leftarrow g$\;
	}
}
$Q\leftarrow T\setminus P$\;
$P'\leftarrow \{\}$\;
\ForEach{$t\in P$}{
		$P'\leftarrow P'\cup\{t/d\}$\;
}
$N_p\leftarrow $\textit{Horner}$(P',S)$ \tcp*[l]{recursive call} 
$N_d\leftarrow $\textit{AddNode}$(S,d)$\;
$N_p\leftarrow $\textit{AddNode}$(S,\left\langle *,N_d,N_p \right\rangle)$\;
\If{$Q\neq\emptyset$}{
$N_q\leftarrow $\textit{Horner}$(Q,S)$ \;
$N_p\leftarrow $\textit{AddNode}$(S,\left\langle +,N_p,N_q \right\rangle)$\;
}
\Return{p}

\label{alg:horner}
\caption{\textsc{Horner(T,S)}}
\end{algorithm}

Например, для полинома $x^2yz+xyz+x^3+xyz+yz^2+z^3+yz+y$ метод Горнера даст схему, соответствующую $x(yz(x+z+1)+x*(x+1))+z(y(z+1)+z^2)+y$, что дает 7 умножений и 8 сложений для задачи вычисления значений, вместо 17 умножений и 8 сложений, если использовать тривиальную схему.
		
	\subsection{Метод минимального покрывающего дерева\label{ss:htree}}
	Рассмотрим орграф по отношению делимости на множестве $M'=M\cup V$ с весами на ребрах, равными некоторой функции частного, например, его полной степени. Нам необходимо выбрать некоторое подмножество ребер этого графа, которое будет отвечать схеме вычисления рассматриваемого набора мономов. Подмножество должно быть таким, чтобы каждый узел из $M\setminus V$ имел ровно одно входящее ребро, с тем чтобы не вычислять один и тот же моном дважды. Заметим, что такое подмножество всегда существует, так как каждый элемент $M\setminus V$ делится на хотя бы один элемент $V$. Пример построения можно видеть на рисунке \ref{fig:mintree}. Здесь для краткости опущены все дуги, кроме соединяющих мономы на соседних уровнях.

	\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.9]{../pic/mintree}
	\caption{Граф делимости (неполный). Черные дуги порождают схему.}
	\label{fig:mintree}
	\end{figure}
	
	Среди всех возможных подмножеств, отвечающих данным критериям, мы выберем одно, обладающее наименьшим весом, и обозначим соответствующий подграф $G_{min}$. Заметим, что название метода не отвечает структуре, которую мы построили -- последняя представляет собой не дерево, а лес из $|V|$ деревьев, причем каждое из деревьев может не являться минимальным покрывающим деревом соответствующего подграфа, в силу ограничения на количество входящих ребер. Тем не менее, аналогия с задачей о минимальном покрывающем дереве кажется нам достаточно ясной.

	Преобразуем, далее, выбранное подмножество в схему. Схема будет содержать по одной операции умножения на каждое ребро $G_{min}$. Ясно, что множители, отвечающие каждому ребру (частное мономов в соседних узлах), входят во множество корневых мономов. Также туда входят первые степени всех переменных, за исключением тех, которые оказались изолированными в $G_{min}$, как, например, моном $(0,1,0)$ на рис. \ref{fig:mintree}. Пример получающейся схемы изображен на рис. \ref{fig:mintreescheme}
	
	\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.9]{../pic/mintreescheme}
	\caption{Схема, построенная по графу на рис. \ref{fig:mintree}. Серым выделены добавочные корневые мономы.}
	\label{fig:mintreescheme}
	\end{figure}

	После того, как подмножество наименьшего веса выбрано, нам остается добавить операции, соответствующие умножению на коэффициенты и суммированию, а также построить схему для вычисления корневых мономов. Очевидно, в данном случае разделение схемы на две части выглядит несколько нелогично. Мы обсудим этот момент и его влияние на эффективность схемы в разд. \ref{ss:addchain}.

%\begin{algorithm}
%\SetAlgoNoLine
%\DontPrintSemicolon
%\KwIn{список $T$ членов полинома в порядке убывания, контейнер схемы $S$}
%$М\leftarrow $\textit{список мономов из Т без коэффициентов}\;
%$V\leftarrow $\textit{список переменных}\;
%$M'\leftarrow M\cup V$\;
%$E\leftarrow \{\}$\;
%\ForEach{$m\in M'$} {
%	$q\leftarrow$ \textit{argmax}$($\textit{TotalDeg}$(q)), q\in M' \& m\vdots q$\;
%	
%}
%
%\ForEach{$t\in T$} {
%	$g\leftarrow $\textit{GCD}$(t,d)$\;
%	\If{TotalDegree$(g)>0$}{
%		$P\leftarrow P\cup\{t\}$\;
%		$d\leftarrow g$\;
%	}
%}
%$Q\leftarrow T\setminus P$\;
%$P'\leftarrow \{\}$\;
%\ForEach{$t\in P$}{
%		$P'\leftarrow P'\cup\{t/d\}$\;
%}
%$N_p\leftarrow $\textit{Horner}$(P',S)$ \tcp*[l]{recursive call} 
%$N_d\leftarrow $\textit{AddNode}$(S,d)$\;
%$N_p\leftarrow $\textit{AddNode}$(S,\left\langle *,N_d,N_p \right\rangle)$\;
%\If{$Q\neq\emptyset$}{
%$N_q\leftarrow $\textit{Horner}$(Q,S)$ \;
%$N_p\leftarrow $\textit{AddNode}$(S,\left\langle +,N_p,N_q \right\rangle)$\;
%}
%\Return{p}
%
%\label{alg:horner}
%\caption{\textsc{MinTree(T,S)}}
%\end{algorithm}


Рассмотрим пример. Пусть задан полином $x^2yzw+xy^2zw+xyz^2w+xyzw^2$. ММПД в этом случае построит схему вида $x(xyzw+y^2zw+yz^2w+yzw^2)$, тогда как интуитивно оптимальной будет $xyzw(x+y+z+w)$. Проблема заключается в неспособности данного метода добавлять промежуточные мономы. Если добавить такую возможность, то мы получим интересный метод, предположительно уступающий по эффективности методу аддитивных цепочек, но превосходящий и метод Горнера, и ММПД. В рамках данной работы мы не будем рассматривать его подробнее.

	\subsection{\ssvm{} и аддитивные цепочки\label{ss:addchain}}
	Схемы совместного вычисления мономов, как было указано выше, является частным случаем схем вычисления полиномов. В отличие от последних, они содержат лишь операции умножения мономов. Исторически, однако, задача совместного вычисления мономов рассматривалась независимо.

		Задача совместного вычисления мономов часто формулируется в терминах \textit{аддитивных цепочек}. 
		
		Аддитивной цепочкой (addition chain) в $n$-мерном пространстве называется последовательность ${a_i}$ целочисленных векторов, первыми $n$ членами которой являются элементы канонического базиса, а каждый из следующих элементов представляет собой сумму каких-либо двух предыдущих: 
		$$a_{ij}=\delta_{ij},~~i=1..n,~j=1..n$$
		$$a_i=a_j+a_k,~~j\leq k<i,~~i>n$$

		Целочисленные векторы здесь можно рассматривать как мультииндексы мономов. Тогда сложение векторов будет соответствовать умножению мономов.
		
		Лучше всего на сегодняшний день изучены одномерные аддитивные цепочки -- они применяются в ряде алгоритмов, а том числе в криптографии, для эффективного возведения в степень (\textit{потенцирования}). Бинарный алгоритм возведения в степень является частным случаем алгоритма на основе аддитивных цепочек. Вопрос о длине $l(m)$ кратчайшей аддитивной цепочки, содержащей число $m$, достаточно подробно описан в \cite{lib:knuth}. Для $l(m)$ известна асимптотическая оценка \cite{lib:brauer}: $l(m)\sim log(m)$ (здесь и далее логарифмы по основанию 2). Заметим, что бинарный алгоритм дает цепочку длины $2 log(m)$ в худшем случае.
		
		Задача о кратчайшей одномерной аддитивной цепочке также часто обобщается следующим образом -- вместо одного числа, предлагается найти кратчайшую цепочку, содержащую множество чисел \cite{lib:knuth}. В англоязычной литературе эта обобщенная постановка называется addition \textit{sequence} problem, и мы будем использовать термин \textit{аддитивная последовательность}, так как более подходящего термина нам неизвестно. Длину такой цепочки обозначают $l(m_1, m_2, ..., m_k)$. Длину кратчайшей $k$-мерной аддитивной цепочки обозначают $l([m_1,m_2,...,m_k])$. Интересный результат получен в \cite{lib:olivos} -- показана <<эквивалентность>> двух последних задач. Именно, для любого $k$ и $\{m_i\}_{i=1}^k$, $l([m_1,m_2,...,m_k])=l(m_1, m_2, ..., m_k)+k-1$.
		
		Также установлено \cite{lib:kochergin_degs}, что

	$$\forall k\,L(\bar m_1,\bar m_2,...,\bar m_k)\sim log\left(max_{i=1..k}(\bar m_i)\right),$$

	где $L(\bar m_1,\bar m_2,...,\bar m_k)=max_{\{m_i<\bar m_i\}}l(\{m_i\})$.
		
В некоторых алгоритмах, таких как DSA, используются многомерные аддитивные цепочки. Также в ряде задач используются аддитивные цепочки с вычитанием -- они могут быть короче обычных аддитивных цепочек. Однако, это оправдано лишь в тех случаях, где такая операция допускается целевым доменом и имеет в нем разумную вычислительную сложность.
		
		Также подробно изучен вопрос о сложности построения кратчайшей аддитивной цепочки -- эта задача является NP-полной \cite{lib:downey}. Существуют и достаточно эффективные приближенные алгоритмы \cite{lib:bos95, lib:gordon97, lib:cortes}.
		
		Схему совместного вычисления мономов, очевидно, можно рассматривать как многомерную аддитивную последовательность, однако построение оптимальной схемы сводится к вычислению кратчайшей аддитивной последовательности лишь в случае постоянного критерия качества, например, при вычислении значений мономов в действительных числах с плавающей точкой фиксированной длины или в конечном поле. Если вычисления производятся в целых числах, кратчайшая аддитивная последовательность уже не соответствует, строго говоря, оптимальной схеме вычисления. В таких задачах, как возведение полинома в степень, неоптимальность таких схем была также подтверждена экспериментально (этот факт упоминается в \cite{lib:knuth}). Логично предположить, что для задачи редукции полинома, где сложность варьируется еще сильнее, схема, соответствующая кратчайшей аддитивной последовательности, будет далека от оптимальной. Тем не менее, такая схема содержит ценную информацию о структуре рассматриваемого набора мономов, и определенно заслуживает рассмотрения, возможно, с некоторыми модификациями.		
	\subsection{Метод аддитивных цепочек\label{ss:addchmethod}}
	...
	\subsection{Схемы специального вида\label{ss:special}}
		Для некоторых полиномов специального вида можно построить более эффективные схемы, используя информацию об их структуре. В качестве примера, рассмотрим задачу совместного вычисления мономов для носителя некоторого плотного полинома.
		
	\begin{thdef}
	Полином $p$ называется плотным, если $$\left(\exists x\in V\, x\in s(p)\right)\, \wedge\, \left(\forall \alpha\in s(p)\, \exists \beta \in s(p), x\in V\, \alpha=x\beta\right).$$			
	\end{thdef}
		
		Значение плотного полинома с $n$ членами может быть вычислено за не более чем $n-1$ операций умножения и $n-1$ операций сложения. Построение соответствующей схемы также может быть реализовано весьма эффективно. Легко видеть, однако, что такую же схему можно построить и методом минимального покрывающего дерева. Мы не будем рассматривать данный алгоритм подробнее в рамках данной работы, так как класс приложений, для которых преимущество в скорости построения схемы вычисления для плотных полиномов дает существенный выигрыш в производительности, достаточно узок.
