\section{Эффективная редукция разреженных полиномов\label{s:increduction}}
	Редукция зачастую осуществляется относительно набора полиномов, не являющегося базисом Грёбнера. В этом случае результат не единственен и может зависеть от используемого алгоритма редукции. Однако, можно говорить о нормальной форме полинома в более общем смысле, если зафиксировать метод редукции. В данном разделе мы будем использовать термин <<нормальная форма>> в этом нестрогом смысле, имея ввиду некоторый полином, полученный редукцией данного относительно заданного набора и нередуцируемый относительно него
	
Также следует обратить внимание на тот факт, что мы используем два различных метода редукции, первый из которых может быть выбран относительно произвольно, а второй -- (\mir) -- строится на основе первого.
	
	\subsection{Задача редукции\label{ss:reductionstatement}}
	Задача редукции полинома $p$ относительно набора полиномов $H$ суть задача поиска остатка от деления этого полинома на них. Простейший подход \cite{lib:cox} к его нахождению заключается в последовательном вычитании $h\in H$ из $p$ с некоторыми множителями. Чтобы гарантировать, что редукция в какой-то момент завершится, обычно фиксируют некоторое \textit{допустимое мономиальное упорядочение} и используют на каждом шаге один из полиномов, чей старший член (в смысле указанного упорядочения) делит старший член рассматриваемого полинома, а в качестве множителя используется их частное.
	
	Когда же вычитание выполнить нельзя, старший член полинома перемещается в остаток, и процедура повторяется до тех пор, пока $p$ не окажется равным нулю. 
	
	%[простой алгоритм редукции: псевдокод]
	
	%[Оценка сложности]
	
	На практике, низкая эффективность алгоритма редукции часто связана с ростом количества промежуточных мономов. В процессе редукции количество членов полинома может интенсивно расти. Рассмотрим, в качестве примера, набор 
	$$G=\{x_1^2-(1 + \sum_{i=2}^m x_i)\}\cup\{x_i|i=2..m\}.$$
Теперь редуцируем $x^{2n}$ относительно $G$. Если применять первое правило, пока это возможно, мы получим полином $(1+\sum_{i=2}^m x_i)^n$, содержащий $C^{n+m-2}_{n}$ членов, который затем будет редуцирован к 0. Данный пример является искусственным и на практике число промежуточных членов обычно не растет настолько интенсивно, однако существенное влияние этого фактора на эффективность алгоритма редукции установлено.

%[картинка с картой мономов в (x,y)]

	\mir{} направлен на сокращение количества промежуточных членов, и в большинстве случаев он позволяет этого достичь, однако можно привести примеры, когда использование обычной редукции более эффективно.
	
	%Приведем пример: пусть необходимо редуцировать $x^5*y^5$ относительно $\{xy^3-xy^2-xy-x,x^2y-xy-y\}$. 
	
	%[пример последовательной редукции]
	
	%[последовательно не всегда быстрее]

Данный подход наиболее эффективен в тех случаях, когда идеал, порожденных полиномами, относительно которых производится редукция, является нульмерным. Кроме того, данный подход демонстрирует высокую эффективность по сравнению с обычным алгоритмом редукции в тех случаях, когда носитель редуцируемого монома содержит много мономов и сильно разрежен.

	\subsection{Описание метода\label{ss:incnormdesc}}
	\mir{} основан на двух свойствах нормальных форм (\ref{eq:nf:props:sum},~\ref{eq:nf:props:prod}). Первое из них -- линейность оператора нормализации. Второе заключается в том, что нормальная форма произведения двух полиномов равна нормальной форме произведения их нормальных форм.
	
\begin{equation}
	\label{eq:nf:props:sum}
	N(\lambda p + \mu q)=\lambda N(p) + \mu N(q)
\end{equation}
\begin{equation}
	\label{eq:nf:props:prod}
	N(p\cdot q)=N(N(p)\cdot N(q))
\end{equation}
	
	Используя эти правила, можно определить пространство нормальных форм по заданному базису. Легко видеть, что оно изоморфно факторалгебре по идеалу, заданному рассматриваемым базисом. 
	
\begin{equation}
	\label{eq:nf:nfspace:sum}
	\lambda p +_n \mu q=\lambda p + \mu q
\end{equation}
\begin{equation}
	\label{eq:nf:nfspace:prod}
	p \cdot_n q=N(p\cdot q)
\end{equation}	
	
	Итак, \mir{} представляет собой операцию подстановки -- или \textit{замены переменных} -- в факторалгебре. Данную подстановку можно рассматривать как тождественную -- как правило, не изменяются даже имена переменных, -- но не следует забывать, что она выполняется в другом пространстве.
	
	Заметим также, что в определении операции умножения в пространстве нормальных форм присутствует оператор нормализации. Ему соответствует некоторый алгоритм редукции, не совпадающий с \mir{}, так как в противном случае определение последнего было бы некорректным. Мы обсудим этот оператор подробнее в разделе \ref{ss:nfcacheimpl}.
	
	Чтобы редуцировать полином при помощи данного метода, необходимо
	\begin{itemize}
		\item вычислить нормальные формы мономов нижнего уровня,
		\item выполнить операции согласно схемы, используя (\ref{eq:nf:nfspace:sum},~\ref{eq:nf:nfspace:prod}),
		\item вернуть результат последней операции в качестве ответа.
	\end{itemize}

	\subsubsection{Сложность операций умножения\label{sss:criteriainconsistency}}
	Очевидно, что эффективность метода существенно зависит от используемой схемы, причем аппроксимировать критерий качества в данном случае весьма проблематично -- сложность редукции двух мономов, сигнатуры которых отличаются на единицу, может различаться в произвольное число раз.
	
В двумерном случае множество мономов можно изобразить графически (рис. \ref{fig:diag}). Множество редуцируемых мономов, которые можно получить из нередуцируемых мономов путем умножения их на первую степень одной из переменных, будем называть \textit{достаточным множеством редуцируемых мономов} (ДМ), так как зная нормальные формы все мономов в нем, мы можем вычислить нормальную форму любого полинома относительно данного базиса, не выполняя более никаких редукций. ДМ можно рассматривать как своего рода таблицу умножения.

Однако, множество нередуцируемых мономов (и, следовательно, ДМ) конечны лишь для нуль-мерных идеалов, и даже в этом случае вычислять все нормальные формы заранее нет необходимости (это может быть слишком дорого) -- мы можем редуцировать те мономы, которые появляются в процессе вычислений. Это реализуется посредством механизма кеширования нормальных форм.

Если потребовать, чтобы нормальная форма каждого монома вычислялась не более чем единожды, то суммарная сложность всех редукций в случае нульмерного идеала будет ограничена. Следовательно, поиск нормальной формы любого полинома можно будет выполнить за полиномиальное время от его длины и степени.

	\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.6]{../pic/diagram}
	\caption{Светло-серым изображена область нередуцируемых мономов, темно-серым -- ДМ.}
	\label{fig:diag}
	\end{figure}
		
В данной работе мы реализуем такую схему кеширования (см. \ref{ss:nfcacheimpl}), отвечающую указанному требованию, и оцениваем ее эффективность. Следует заметить, что данная идея не нова -- она используется, в частности, в \cite{lib:kliskunov}. Есть также определенные основания полагать, что некоторая схожая схема кеширования реализована в системе компьютерной алгебры Singular.

	Что касается операций сложения и умножения на число, их стоимость, как правило, мала по сравнению со стоимостью операции умножения. Кроме того, как мы указали выше, количество таких операций отстается постоянным во всех схемах, генерируемых рассматриваемыми методами. 

	\subsection{Наращивание схемы\label{ss:improvements}}
		\mir{} демонстрирует высокую эффективность в наших экспериментах. Однако, с тем, чтобы узнать его сильные и слабые стороны, следует рассматривать фактическую сложность выполнения отдельных операций. Мы полагаем, это позволит как улучшить алгоритм вычисления в соответствии с заданной схемой, так и построить более точный приближенный критерий сложности, с тем чтобы генерировать более эффективные схемы.
		
		В разделе \ref{s:results} мы обсудим некоторые эксперименты с данным алгоритмом. Наблюдая работу \mir{}, мы пришли к выводу, что, вероятно, модификация схемы в процессе выполнения редукции может дать существенный прирост производительности. Дело в том, что при редукции могут возникать новые мономы, которых не было в исходном полиноме, и их редукция может потребовать значительного времени. В то же время, велика вероятность, что мы уже знаем нормальную форму одного или нескольких мономов, которые делят рассматриваемый моном. Используя эти мономы, мы можем <<достроить>> фрагмент схемы, с тем чтобы включить в нее новый моном.
		
		Развивая эту идею, мы неизбежно приходим к заключению, что строить схему лучше прямо в процессе ее выполнения, так как мы обладаем в этот момент дополнительной информацией, которая не была доступна ранее. Например, дополнительные мономы, добавленные в схему в процессе редукции, могут позволить нам достичь целевых мономов более коротким путем.
		
		Схему можно наращивать двумя способами -- <<в ширину>> или <<в глубину>>. Какой из подходов предпочтителен -- неясно, -- это требует экспериментальной проверки. Кроме того, не вполне ясно, достаточно ли планировать схему на каждом шаге для всех оставшихся мономов, какого-то одного из них, или некоего подмножества, а также, насколько критично качество промежуточной схемы в этом случае.
		
		К сожалению, мы не имеем возможности вполне исследовать данный вопрос в рамках данной работы.
