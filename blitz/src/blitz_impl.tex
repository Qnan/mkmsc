\section{Детали реализации\label{s:implementation}}
В рамках данной работы была реализована библиотека для работы с полиномами над полем рациональных чисел или конечным полем с учетом специфики рассматриваемой задачи на языке \texttt{C++}. При помощи данной библиотеки был реализован ряд описанных ранее алгоритмов с целью сравнения их эффективности между собой и с системой компьютерной алгебры Maple 14 \cite{lib:maple}, а также выявления потенциальных путей повышения эффективности рассматриваемых алгоритмов.  

При реализации библиотеки использованы некоторые базовые контейнеры, механизм ввода-вывода и средства анализа эффективности кода из библиотеки Indigo API \cite{lib:indigo}, распространяемой под лицензией GPL. 

	\subsection{Прототипирование\label{ss:proto}}
	На стадии прототипирования описанные методы построения схем -- метод Горнера и ММПД, -- а также алгоритм вычисления значений полинома по заданной схеме были реализованы на языке Python. Позднее они были также перенесены на C++ с целью повышения эффективности, а также во избежание дублирования отдельных процедур работы с полиномами.
	
	\subsection{Представление мономов\label{ss:monorep}}
	Представление мономов в программных пакетах компьютерной алгебры изучено достаточно хорошо. Анализ эффективности различных представлений можно найти в \cite{lib:bachmann}. Мы используем представление в виде вектора степеней с полной степенью.
	
	Анализа состава набора мономов, используемых в процессе редукции полиномов, показал, что многие мономы низких степеней используются повторно. Чтобы снизить потребление памяти и повысить эффективность библиотеки в целом, мы храним все уникальные мономы, используемые в данный момент времени в специальной структуре данных на основе хэш-таблицы с подсчетом ссылок. Таким образом, мономам присваиваются уникальные номера, что существенно упрощает реализацию механизма кеширования нормальных форм.

	На осонове анализа работы алгоритма редукции для полиномов высоких степеней мы также пришли к выводу, что удаление мономов при обнулении счетчика ссылок не является необходимым, так как количество используемых мономов обычно растет практически в течение всего времени работы алгоритма, после чего резко падает. Мы не выполняем формального сравнения такого подхода с традиционным, так как используемые в данной работе алгоритмы в любом случае требуют наличия у мономов уникальных ключей, т.е. накладных расходов на поддержание структуры с уникальными мономами не избежать. Однако, мы допускаем, что такой подход может быть плохо приспособлен для систем компьютерной алгебры общего назначения.	 
	
	Поддерживаются лексикографическое и градуированное обратное лексикографическое упорядочения.
	
	\subsection{Представление полиномов\label{ss:polyrep}}
	Полиномы представлены в виде списков с общим пулом элементов. Это означает, что при создании нового полинома выделяется лишь небольшой объем памяти на стеке, а память, выделенная в общем пуле для членов полинома, может быть использоана повторно после уничнтожения данного объекта -- это особенно полезно при реализации алгоритма редукции, где возникает большое количество промежуточных полиномов.
	
	В качестве коэффициентов могут выступать элементы конечного поля, чей модуль не превышает $2^{31}$, либо рациональные числа произвольной точности. Последние реализованы посредством библиотеки GMP \cite{lib:gmp}, которая представляет собой де-факто стандарт вычислений произвольной точности и используется в таких системах компьютерной алгебры как Mathematica, Maple и Singular, а также во множестве других программных пакетов и приложений.

	\subsection{Кеширование нормальных форм мономов\label{ss:nfcacheimpl}}
	Как было сказано выше, используемый способ представления мономов автоматически дает нам уникальные идентификаторы для них, поэтому реализация кеша нормальных форм мономов не представляет сложности. Внимания заслуживает вспомогательный алгоритм редукции, используемый в нашей реализации \mir{}. Нашей целью было гарантировать, что нормальная форма любого нужного нам монома будет вычислена лишь однажды (если только мы не удалим ее из кеша явно, например, с целью высвобождения памяти).

	\begin{algorithm}[ht]
	\SetAlgoNoLine
	\DontPrintSemicolon
	\caption{\textsc{AuxReduce(m,G,T)}}
	\KwIn{моном $m$, базис $G$, кеш нормальных форм $T$}
	\KwOut{нормальная форма монома $m$}
	\If{HasKey(T,m)}{
		\Return{$T[m]$} \tcp*[l]{monomial cached}
	}
	\ForEach{$g\in G$} {
		$lm\leftarrow$\textit{LeadingMonomial}$(g)$\;
		\If{$lm$ divides $m$} {
			$p\leftarrow m - m\cdot g / lm$\;
			$q\leftarrow 0$\;
			\ForEach{term $t\in p$} {
				$q\leftarrow q + $\textit{Coefficient}$(t)\cdot $\textit{AuxReduce}$($\textit{Monomial}$(t),G,T)$   \tcp*[l]{recursive call}
			}
			$T[m]\leftarrow q$\;
			\Return{$T[m]$}
		}
	}
	$T[m]\leftarrow m$ \tcp*[l]{monomial is irreducible}
	\Return{$T[m]$}\;
		
	\label{alg:auxreduce}
	\end{algorithm}

	Итак, вспомогательный алгоритм редукции получает на вход моном $m$ и должен вернуть в качестве результата его нормальную форму, также записав ее в кеш. Нормальные формы всех промежуточных мономов, потребовавшихся нам в процессе редукции, также должны попасть в кеш.
	
	Соответствие предложенного алгоритма (\ref{alg:auxreduce}) указанным условиям легко проверить. Ясно, что нормальная форма всякого монома, вычисленная данным алгоритмом, будет помещена в кеш. Остается удостовериться, что редукция одиного и того же монома не будет выполнена дважды. Это возможно лишь в случае, если данный моном окажется промежуточным продуктом редукции самого себя. Однако все мономы $p$ строго меньше $m$ в смысле заданного упорядочения, и, по индукции, все мономы, могущие встретиться в процессе редукции мономов из $p$ также строго меньше $m$. Следовательно, указанная ситуация невозможна и алгоритм удовлетворяет указанным требованиям.
	
	Заметим, что практическая реализация данного алгоритма не является рекурсивной, так как для полиномов высоких степеней это могло бы привести к переполнению стека в процессе работы алгоритма.
		
	\subsection{Реализация \svp\label{ss:svpimpl}}
	Представление \svp{} в программе практически в точности повторяет формальное определение -- это последовательность операций вида:
	\begin{itemize}
		\item вычислить нормальные формы мономов ${m_1, m_2, ..., m_k}$ и записать в первые $k$ ячеек памяти
		\item вычислить сумму или произведение полиномов в ячейках $i$ и $j$ и записать в ячейку $r$
		\item вычислить произведение полинома в ячейке $i$ и коэффициента $f$ и записать в ячейку $r$
	\end{itemize}
	
	Классы, реализующие вычисление значений полинома, \mir{} и подсчет количества операций в схеме, представляют собой интерпретаторы такой программы.
	
	\subsection{Поддерживаемые операции для мономов и полиномов\label{ss:interfacesimpl}}
	Приведем список операций, реализованных для мономов:
	\begin{itemize}
		\item создание монома с заданной мультистепенью
		\item создание монома на основе строки, например $x1^4*x2^7$
		\item вычисление произведения, частного и наибольшего общего делителя мономов
		\item проверка делимости и равенства
		\item сравнение в заданном упорядочении
		\item получение степени конкретной переменной и полной степени
		\item вывод монома в текстовой форме.
	\end{itemize}
	
	Полиномы поддерживают
	\begin{itemize}
		\item добавление и удаление членов
		\item загрузку из строки и сохранение в строку
		\item сложение и умножение на число (коэффициент)
		\item перебор членов
		\item получение старшего члена
		\item сортировку согласно заданного упроядочения.
	\end{itemize}	